package index

import (
	"sync"
)

// MemoryOccurrences contain map of document to positions
type MemoryOccurrences map[string][]int

type MemoryIndex struct {
	index   map[string]MemoryOccurrences
	sources map[string]*Source
	m       *sync.RWMutex
}

func NewMemoryIndex() *MemoryIndex {
	i := &MemoryIndex{
		index:   map[string]MemoryOccurrences{},
		sources: map[string]*Source{},
		m:       &sync.RWMutex{},
	}
	return i
}

func (i *MemoryIndex) Add(token string, position int, source Source) error {
	i.m.Lock()
	defer i.m.Unlock()
	if _, ok := i.sources[source.Name]; !ok {
		i.sources[source.Name] = &source
	}
	if _, ok := i.index[token]; !ok {
		i.index[token] = map[string][]int{}
	}
	if _, ok := i.index[token][source.Name]; !ok {
		i.index[token][source.Name] = []int{}
	}
	i.index[token][source.Name] = append(i.index[token][source.Name], position)
	return nil
}

func (i *MemoryIndex) Get(token string) (Occurrences, error) {
	i.m.RLock()
	defer i.m.RUnlock()
	result := Occurrences{}
	for document, positions := range i.index[token] {
		source := i.sources[document]
		result[source] = positions
	}
	return result, nil
}

// Encoder is the interface implemented by the object that can encode data from the MemoryIndex.
type Encoder interface {
	// Encode must be able to encode data generated by Decode function.
	Encode(e interface{}) error
}

// Encode is the thread-safe function to encode MemoryIndex.
func (i *MemoryIndex) Encode(encoder Encoder) error {
	i.m.RLock()
	defer i.m.RUnlock()

	return encoder.Encode(i)
}

// Decoder is the interface implemented by the object that can decode data into the MemoryIndex.
type Decoder interface {
	// Decode must be able to decode data generated by Encode function.
	Decode(e interface{}) error
}

// Decode is the thread-safe function to extract index from the encoded data.
func Decode(decoder Decoder) (*MemoryIndex, error) {
	i := NewMemoryIndex()
	i.m.Lock()
	defer i.m.Unlock()
	return i, decoder.Decode(i)
}
